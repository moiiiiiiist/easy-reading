<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>自动滚动测试</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #333;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
        }
        
        .controls button {
            display: block;
            width: 120px;
            margin: 5px 0;
            padding: 10px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .controls button:hover {
            background: #0056b3;
        }
        
        .sentence {
            padding: 10px;
            margin: 5px 0;
            border-left: 3px solid transparent;
            transition: all 0.3s ease;
            background: #f8f9fa;
            border-radius: 4px;
        }
        
        .sentence.current {
            background: #fff3cd;
            border-left-color: #ffc107;
            box-shadow: 0 2px 5px rgba(255,193,7,0.3);
        }
        
        .status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #333;
            color: white;
            padding: 10px 15px;
            border-radius: 4px;
            font-size: 14px;
        }
        
        h1 {
            margin-top: 0;
            color: #333;
        }
        
        .debug {
            position: fixed;
            top: 20px;
            left: 20px;
            background: #dc3545;
            color: white;
            padding: 10px 15px;
            border-radius: 4px;
            font-size: 12px;
            font-family: monospace;
            max-width: 200px;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>自动滚动功能测试</h1>
        <p>这个页面用来测试自动滚动功能。点击右侧的按钮可以导航到不同的句子，页面应该自动滚动到对应位置。</p>
        
        <div id="content">
            <!-- 这里会动态生成很多句子 -->
        </div>
    </div>
    
    <div class="controls">
        <button onclick="previousSentence()">上一句</button>
        <button onclick="nextSentence()">下一句</button>
        <button onclick="jumpToSentence(0)">跳到开头</button>
        <button onclick="jumpToSentence(Math.floor(sentences.length/2))">跳到中间</button>
        <button onclick="jumpToSentence(sentences.length-1)">跳到末尾</button>
        <button onclick="toggleAutoScroll()">切换自动滚动</button>
    </div>
    
    <div class="status">
        当前句子: <span id="current-index">0</span> / <span id="total-sentences">0</span>
    </div>
    
    <div class="debug" id="debug">
        调试信息:<br>
        滚动状态: <span id="scroll-status">--</span><br>
        视口检测: <span id="viewport-status">--</span><br>
        强制滚动: <span id="force-status">--</span><br>
        <strong>懒滚动原因: <span id="scroll-reason" style="color: #2196F3;">句子在安全区域</span></strong>
    </div>

    <script>
        // 生成测试数据
        const sentences = [
            "这是第一个句子，用来测试自动滚动功能。",
            "当你点击下一句按钮时，页面应该自动滚动到这个句子。",
            "滚动功能对于长文章的阅读体验非常重要。",
            "用户不应该需要手动滚动来查看当前正在朗读的句子。",
            "我们实现了智能的视口检测功能。",
            "只有当句子不在可视区域时才会触发滚动。",
            "这样可以避免不必要的滚动干扰。",
            "同时我们还支持强制滚动模式。",
            "当用户主动点击导航按钮时会强制滚动。",
            "这确保了用户总能看到他们想要的内容。"
        ];
        
        // 生成更多句子来测试长页面滚动
        for (let i = 10; i < 100; i++) {
            sentences.push(`这是第${i + 1}个句子。这个句子的内容足够长，可以让我们测试在长文档中的滚动行为。每个句子都有独特的编号，方便我们跟踪当前位置。`);
        }
        
        let currentSentenceIndex = 0;
        let autoScrollEnabled = true;
        
        // 初始化页面
        function init() {
            const content = document.getElementById('content');
            content.innerHTML = sentences.map((sentence, index) => 
                `<div class="sentence" data-index="${index}">${sentence}</div>`
            ).join('');
            
            document.getElementById('total-sentences').textContent = sentences.length;
            updateCurrentSentence();
        }
        
        // Utils 类的简化版本
        const Utils = {
            isInViewport(element, offset = 120) {
                const rect = element.getBoundingClientRect();
                const result = (
                    rect.top >= offset &&
                    rect.left >= 0 &&
                    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) - offset &&
                    rect.right <= (window.innerWidth || document.documentElement.clientWidth)
                );
                
                // 更新调试信息
                document.getElementById('viewport-status').textContent = result ? '在视口内' : '不在视口';
                
                return result;
            },
            
            isNearViewportBottom(element, thresholdPercent = 0.1) {
                const rect = element.getBoundingClientRect();
                const viewHeight = window.innerHeight || document.documentElement.clientHeight;
                
                // 将百分比转换为像素阈值
                const threshold = viewHeight * thresholdPercent;
                
                return rect.bottom > (viewHeight - threshold);
            },
            
            needsLazyScroll(element) {
                if (!element) return false;
                
                const rect = element.getBoundingClientRect();
                const viewHeight = window.innerHeight || document.documentElement.clientHeight;
                
                // 如果句子完全不在视口中，需要滚动
                if (rect.bottom <= 0 || rect.top >= viewHeight) {
                    document.getElementById('scroll-reason').textContent = '句子不在视口中';
                    return true;
                }
                
                // 如果句子接近视口底部，需要滚动到下一页（10%阈值）
                if (this.isNearViewportBottom(element, 0.1)) {
                    document.getElementById('scroll-reason').textContent = '句子接近底部 (距底部<10%)';
                    return true;
                }
                
                document.getElementById('scroll-reason').textContent = '句子在安全区域';
                return false;
            },
            
            smoothScrollToSentence(element, options = {}) {
                document.getElementById('scroll-status').textContent = '正在滚动';
                
                requestAnimationFrame(() => {
                    element.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start',
                        inline: 'nearest',
                        ...options
                    });
                    
                    setTimeout(() => {
                        document.getElementById('scroll-status').textContent = '滚动完成';
                    }, 500);
                });
            }
        };
        
        function updateCurrentSentence(forceScroll = false) {
            // 更新调试信息
            document.getElementById('force-status').textContent = forceScroll ? '强制滚动' : '智能滚动';
            
            // 移除之前的current类
            document.querySelectorAll('.sentence.current').forEach(el => {
                el.classList.remove('current');
            });
            
            // 添加current类到当前句子
            const currentElement = document.querySelector(`[data-index="${currentSentenceIndex}"]`);
            if (currentElement) {
                currentElement.classList.add('current');
                
                // 懒滚动逻辑：只在必要时滚动
                if (autoScrollEnabled && (forceScroll || Utils.needsLazyScroll(currentElement))) {
                    Utils.smoothScrollToSentence(currentElement);
                } else {
                    document.getElementById('scroll-status').textContent = '无需滚动';
                }
            }
            
            // 更新状态显示
            document.getElementById('current-index').textContent = currentSentenceIndex + 1;
        }
        
        function previousSentence() {
            if (currentSentenceIndex > 0) {
                currentSentenceIndex--;
                updateCurrentSentence(true); // 强制滚动
            }
        }
        
        function nextSentence() {
            if (currentSentenceIndex < sentences.length - 1) {
                currentSentenceIndex++;
                updateCurrentSentence(true); // 强制滚动
            }
        }
        
        function jumpToSentence(index) {
            if (index >= 0 && index < sentences.length) {
                currentSentenceIndex = index;
                updateCurrentSentence(true); // 强制滚动
            }
        }
        
        function toggleAutoScroll() {
            autoScrollEnabled = !autoScrollEnabled;
            const button = event.target;
            button.textContent = autoScrollEnabled ? '切换自动滚动' : '自动滚动(已关闭)';
            button.style.background = autoScrollEnabled ? '#007bff' : '#dc3545';
        }
        
        // 键盘支持
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowLeft':
                    e.preventDefault();
                    previousSentence();
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    nextSentence();
                    break;
            }
        });
        
        // 初始化
        init();
    </script>
</body>
</html> 